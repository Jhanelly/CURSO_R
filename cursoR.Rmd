---
title: "Curso de Importación y Manipulación de datos con R"
author: "Jhanelly Chalá"
output: 
  rmdformats::readthedown:
    toc_depth: 3
    lightbox: true
---

```{=html}
<style>

h1.title {
  text-align: center;
}

body {
  text-align: justify;
  text-justify: inter-word;
}

</style>
```
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=TRUE)
```

# Importar datos con R

![](https://d33wubrfki0l68.cloudfront.net/571b056757d68e6df81a3e3853f54d3c76ad6efc/32d37/diagrams/data-science.png){alt="Flujo de Trabajo para Analítica de Datos en R: Inspirado por las Técnicas de Wickham y Grolemund" style="display: block; margin-left: auto; margin-right: auto;" width="60%"}

::: {style="text-align: center;"}
Flujo de Trabajo para Analítica de Datos en R: Inspirado por las Técnicas de Wickham y Grolemund
:::

La imagen presentada ilustra un modelo de herramientas necesarias para trabajar con datos, propuesto por Hadley Wickham & Garret Grolemund.

En esta primera sección del curso cubriremos la importación de datos, una acción fundamental para poder hacer análisis de datos.

En R se pueden cargar datos de diferentes tipos de archivos como por ejemplo:

|       |                            |
|-------|----------------------------|
| .csv  | Datos separados por comas  |
| .dta  | Datos de Stata             |
| .sav  | Datos provenientes de SPSS |
| .xlsx | Datos excel                |

¡Y muchos más, continua leyendo!

**¿Por qué en importante conocer la ruta de trabajo?**

Trabajar en un espacio de trabajo predefinido facilita la importación de datos, dado que no es necesario especificar la ruta completa del archivo en cada importación. Por tal motivo, se recomienda almacenar toda la información en una misma ruta.

Otra recomendación útil es organizar tus tareas, trabajos e investigaciones en proyectos separados. De esta manera, cada vez que abras una sesión en un proyecto específico, la ruta de trabajo ya estará predefinida según la ubicación donde se almacene dicho proyecto. Esto facilita el manejo de archivos y mejora la eficiencia en el acceso a los recursos necesarios.

**Conoce tu diractorio de trabajo**:

```{r}
getwd() #Obtendras una salida parecida a esta:

```

**¿Puedo cambiar mi directorio de trabajo?**

Si deseas usar otra ruta distinta para importar tus archivos lo puedes hacer con el siguiente comando:

```{r}
#Dentro de los parentesís deberas colocar tu ruta 
setwd("C:/Users/USUARIO/Documents/Publicaciones/CURSO_R")
```

**NOTAS:**

1.  Recuerda que tienes que usar **\\\\** o **/**, además toda la ruta debe estar dentro de las comillas.

2.  Al iniciar una nueva sesión, la ruta de trabajo se restablecerá\

Si deseas prácticar con los datos usados aquí, puedes descargarlos [aquí](https://github.com/Jhanelly/CURSO_R.git)

### Importación de datos tabulares 

No es necesario instalar paquetes adicionales para importar datos de extensión .csv Se puede hacer desde el paquete base que contiene R.

Prueba lo siguiente:

```{r eval=FALSE}
read.csv("Nombre_del_archivo.csv", col_names = FALSE, 
         skip = n)
```

`col_names=TRUE:` Indica que la primera fila corresponde a los nombres de las columnas, `skip=n`Omite las primeras 'n' filas del archivo antes de comenzar a leer los datos.

Recuerda que al estar el archivo dentro de tu ruta de trabajo no necesitas usar toda la ruta del archivo. En caso de que desees importar el archivo desde otra carpeta sin necesidad de cambiar la ruta de trabajo, podrías probar con algo como esto:

**NOTA:**

Puedes utiliza la función `choose.files()` para encontrar la ruta de tu archivo con mayor facilidad.

Si estas trabajando con grandes conjuntos de datos, puedes optar por utilizar el paquete `data.table`, el cual permite optimizar el tiempo y memoria al leer los datos.

```{r eval=FALSE}
#install.packages("data.table")
library(data.table)
dt <- fread("Nombre_del_archivo.csv")
```

### Importar datos de ficheros Stata 

Para importar datos de extensión .dta o .sav se necesita el siguiente paquete:

```{r eval=FALSE}
#install.packages("haven")
library(haven)
read_dta("Nombre_del_archivo.dta")
```

### Importar datos de ficheros SPSS 

```{r eval=FALSE}
library(haven)
read_spss("Nombre_del_archivo.sav") 
```

### Importar datos de excel

Para importar datos de excel puedes usar los paquetes `readxl` o `openxlsx`

```{r}
#install.packages("readxl") #Permite importar archivos
#install.packages("openxlsx") #Permite importar y exportar
library(readxl)
library(openxlsx) 

```

Probemos con el paquete readxl:

```{r eval=FALSE}
read_excel("Nombre_del_archivo.xlsx", sheet = 1)
```

Con el argumento `sheet` puedes especificar el número de hoja a importar o bien el nombre de la misma, ejm: "Precios"

**¿Se puede importar más de un archivo a la vez?**

En nuestros proyectos nos podemos encontrar que deseamos importar más de un archivo, sería engorroso importar uno por uno, sin embargo, no te debes preocupar, las funciones de R se crearon para ayudar!!

**CONSEJO:** Puedes optar por crear en tu ruta una carpeta que contenga especificamente los archivos con la misma extensión que deseas de importar:

Para el ejemplo la nueva carpeta se denomina "bases".

```{r}
files<-list.files(path = "bases",full.names = TRUE)
print(files)
```

`list.files():` Esta es una función en R que se utiliza para listar los nombres de los archivos en un directorio especificado.

`path = "bases":` Este argumento indica el directorio del cual se quieren listar los archivos. En este caso, está buscando en el directorio llamado "bases". Si este directorio está dentro del directorio de trabajo actual, buscará allí; de lo contrario, necesitarás proporcionar una ruta completa o relativa.

`full.names = TRUE:` Este argumento especifica que los nombres de los archivos devueltos deben incluir sus rutas completas. Si estuviera en FALSE (que es el valor predeterminado), list.files() devolvería solo los nombres de los archivos sin la ruta.

Hasta ahora solo hemos guardado los nombres de los archivos, para importarlos puedes hacerlo con el siguiente comando:

```{r message=FALSE, warning=FALSE, paged.print=FALSE, results='hide'}
bases<-lapply(files,read_xls, sheet=1) 
```

El código está aplicando la función read_xls a cada uno de los archivos especificados en files, leyendo la primera hoja de cada archivo Excel y almacenando los resultados en la variable bases.

Extraiga los archivos almacenados en la lista:

```{r}
electricidad <- bases[[1]]
pib <- bases[[2]] 
```

Estas líneas de código están separando los DataFrames individuales almacenados en la lista bases en variables separadas para su uso y análisis más fácil.

### Datos provenientes de Internet

R brinda la facilidad de poder descargar archivos de internet con comandos, ¡Que locura!

Imagina que los datos que necesitas se encuentran en el siguiente url:

```{r}
url <- "https://raw.githubusercontent.com/zkamvar/r-novice-gapminder/main/episodes/data/gapminder_wide.csv"

#Cargar los datos
dato <- read.csv(url)
```

### Web Scraping

El web scraping se utiliza cuando los datos no están disponibles en un formato fácilmente descargable, como un archivo CSV, sino que están incrustados en el HTML de una página web.

Las APIs (Interfaces de Programación de Aplicaciones) son conjuntos de reglas que permiten a las aplicaciones interactuar entre sí. Actúan como intermediarios, facilitando el acceso a funciones o datos de otros servicios de forma estandarizada. Su uso es fundamental para integrar y ampliar las capacidades de las aplicaciones de software.

**API Banco Mundial**

Cargar e instalar el paquete necesario:

```{r}
#install.packages("wbstats")
library(wbstats)
```

Puedes utrilizar el paquete de la siguiente manera:

```{r}
#Países disponibles
wb_countries()
#Indicadores disponibles
wb_indicators() 
#Para obtener los indicadores en español:
wb_indicators(lang = "es") 
#Datos relacionados con turismo
wb_search(pattern = c("Unemployment"))
#Descarga los datos que necesites
paises_latinos <- c("ABW","ARG","ATG","BHS","BLZ","BOL", "BRA","BRB","CHL","COL",
"CRI","CUB","CUW","CYM","DMA","DOM","ECU","GRD","GTM","GUY","HND","HTI","JAM","KNA","LCA","MAF","MEX","NIC","PAN","PER","PRI","PRY","SLV","SUR", "SXM","TCA","TTO","URY","VCT","VEN","VGB","VIR")
desempleo <- wb_data(
  indicator = "SL.UEM.TOTL.ZS", 
  country = paises_latinos,
  start_date = 1960, end_date = 2020)

#Puedes importar más de un indicador:
data <- wb_data(
  indicator = c("SL.UEM.TOTL.ZS","FP.CPI.TOTL.ZG"))

#Si deseas de todos los países y todos los años disponibles, no es necesario que se especifiquen los argumentos country, start_date y end_date.
```

# Manipulación de datos con R

Habiendo importado nuestros datos en R, estamos listos para el siguiente paso en nuestro flujo: la transformación de datos. Aunque el ordenamiento y limpieza ('tidy') son cruciales, nos centraremos primero en transformar los datos, integrando gradualmente el proceso 'tidy' para demostrar su importancia en el análisis de datos.

Empecemos por conocer otro tipo de marco de datos denominado **tibble**. Los tibbles son una versión moderna y mejorada de los data frames en R, diseñados específicamente para el ecosistema Tidyverse. Aunque similares en estructura, los tibbles mejoran la experiencia del usuario con una impresión más amigable en la consola, manejo más intuitivo de las variables no estándar y una mayor compatibilidad con los datos almacenados en formatos diversos. Estas características hacen de los tibbles una opción preferida para el análisis de datos en R.

Almacenemos nuestro datos en un objeto tibble:

```{r}
#install.packages("tibble")
library(tibble)
datos <- as_tibble(dato) #convertir a un tibble
glimpse(datos) #similar a str() pero es útil con los tibble
```

Una vez obtenido los datos en el formato que necesitamos, podemos empezar.

Dentro de R, dplyr es un paquete esencial para la manipulación de datos, este además de tibble forma parte del mundo tidyverse.

```{r message=FALSE, warning=FALSE}
#install.packages("dplyr")
library(dplyr)
```

Los verbos principales que integran sus funciones son:

1.  `filter()`,

2.  `select()`,

3.  `arrange()`,

4.  `mutate()`,

5.  `summarise()` y

6.  `group_by()`.

Cada una de estas funciones juega un papel esencial en la transformación y análisis de datos. Además de estas herramientas fundamentales, también exploraremos funciones adicionales dentro de dplyr para enriquecer tu comprensión y habilidades en el manejo de este paquete.

### Filtrar observaciones

`filter()`permite crear un sub-conjunto de las observaciones de nuestro datos.

-   **Comparaciones**

Conjunto estándar: \>, \>=, \<, \<=, !=(no igual) y ==(igual)

```{r}
#Filtra por el continente que sea Africa
datos %>% filter(continent=="Africa")
#Filtra las observaciones de gdpPercap_1952 que sean mayores o iguales a 5000
datos %>% filter(gdpPercap_1952>=5000)
#Filtra las observaciones de gdpPercap_1952 que tengan valores NA
datos %>% filter(is.na(gdpPercap_1952))

#Filtrar por exepción
#Filtra observaciones en las que el país NO sea Algeria.
datos %>% filter(!country=="Algeria")
```

El operador `%>%`, conocido como el operador de tubería (pipe operator), Permite encadenar múltiples funciones de manera clara y legible, pasando el resultado de una función como primer argumento a la siguiente. Forma parte del paquete `magrittr` pero si ya has cargado `dplyr` previamente, tendrás el operador `%>%` disponible automáticamente.

-   **Operadores lógicos**

El operador \| es un operador lógico "OR" que permite incluir filas que cumplan cualquiera de las dos condiciones.

```{r}
datos %>% filter(country=="Ecuador" | country=="Chile")

#Otra opción es:
#Operador %in%
datos %>% filter(country %in% c("Ecuador", "Chile", "Mexico"))

```

El operador &, que es un operador lógico "AND", lo que significa que ambas condiciones deben ser verdaderas para que una fila sea incluida en el resultado.

```{r}
datos %>% filter(continent=="Europe"& gdpPercap_1952<5000)

#Puedes utilizar:
datos %>% filter(continent=="Europe", gdpPercap_1952<5000)
```

Dentro de la manipulación de casos tambien es útil `distinct()` para obtener solo los registros únicos de la columna

```{r}
datos %>% distinct(continent) 
```

Cuando se trabaja con datos que poseen cadenas de texto, se puede combinar filter con otras funciones de otros paquetes, como por ejemplo: `stringer` uno más del ecosistema tidyverse.

La función `str_detect` se utiliza para identificar si un patrón específico de texto está presente en una cadena de caracteres.

```{r}
library(stringr)
# Filas donde la columna country contiene la letra "o" en cualquier parte de su texto
datos %>% filter(str_detect(country,"o"))
# Filas donde country comienza con la letra "A"
datos %>% filter(str_detect(country,"^A"))
# Filas en donde las cadenas terminen con la letra "s"
datos %>% filter(str_detect(country,"s$"))
```

### Seleccionar variables

`select()` Permite obtener un subconjunto de datos solo con las variables (columnas) de interés.

Seleccionar Columnas Específicas:

```{r}
datos %>% select(country, gdpPercap_1952, lifeExp_1952, pop_1952)
```

Excluir columnas:

```{r}
#Una
datos %>% select(-continent)
#Múltiples
datos %>% select(-continent, -gdpPercap_1957)
#Forma adicional
datos %>% select(-c(continent, gdpPercap_1957))
#Rango de columnas
datos %>% select(country,gdpPercap_1957:gdpPercap_2007) 
```

Dentro de `select()` puedes utilizar otras funciones de ayuda:

```{r}
#Columnas que inicien con "lifeExp"
datos %>% select(country,starts_with("lifeExp"))

#Seleccionar columnas que contengan "Gdp":
datos %>% select(country, contains("Gdp"))

#Seleccionar columnas que finalicen con "1997":
datos %>% select(country, ends_with("1997"))
```

El orden de las variables tambien se establece con select(), así que si deseas colocar una columna al inicio de todas las demás, se puede usar:

```{r}
#Mueve la columna country al principio del conjunto de datos, manteniendo todas las demás columnas en su orden original.
datos %>% select(country,everything())
```

### Reorganizar variables

Para cambiar la posición de las columnas tambien se puede utilizar `relocate()`:

```{r}
#La función relocate() por defecto coloca la columna especificada al inicio del conjunto de datos:
datos %>% relocate(country)
#Mover una Columna a una Posición Específica
#Caso 1
#El argumento .before=gdpPercap_1952 indica que lifeExp_1997 debe ser colocada antes de gdpPercap_1952
datos %>% relocate(c(lifeExp_1997, pop_1997),.before=gdpPercap_1952)

#Caso 2
#El argumento .after=gdpPercap_1952 indica que lifeExp_1997 debe ser colocada antes de gdpPercap_1952
datos %>% relocate(c(lifeExp_1997, pop_1997),.after=gdpPercap_1952)

```

### Organizar filas

`arrange()` se utiliza para ordenar las filas de un conjunto de datos

```{r}
#Orden ascendente
datos %>% arrange(country)
#Orden descendente
datos %>% arrange(desc(gdpPercap_1952))
#Ordenar por varias columnas
datos %>% arrange(continent,desc(country))
#Esta última linea indica que se ordenará de forma ascendente por la variable continent y luego ordenara de forma descendente por la variable country.

#Nota: Al ser caracteres el orden es alfabetico
```

### Datos tipo rectangulares

Aun tenemos unos verbos más que aprender, sin embargo, antes de ver los demás, me parece un buen momento para retomar un paso importante nombrano en los parrafos anteriores: tidy.

En nuestro conjunto de datos, que actualmente presenta una estructura "ancha" con columnas separadas para cada año y cada indicador (como gdpPercap_1952, lifeExp_1952, etc.), vamos a realizar una transformación para adoptar un formato "largo" o "rectangular".

En el formato rectangular, cada fila representará una observación única para un país en un año específico, con columnas dedicadas para year, gdpPercap, lifeExp, y pop.

Función `pivot_longer()`: Esta función convierte datos de un formato ancho a un formato largo.

```{r}
#install.packages("tidyr")
library(tidyr)
datos_pivot <- datos %>% 
  pivot_longer(cols = -c(continent, country),
                names_to="indicador",
                values_to = "Valor")  
```

-   `cols = -c(continent, country)`: Selecciona todas las columnas excepto continent y country para pivotar. El signo - indica que estas columnas se deben excluir del proceso de pivotar.

-   `names_to="indicador"`: Los nombres de las columnas seleccionadas para pivotar se guardarán en una nueva columna llamada indicador.

-   `values_to = "Valor"`: Los valores correspondientes de las columnas pivotadas se almacenarán en una columna llamada Valor

```{r}
#Observemos nuestros datos
datos_pivot

```

Aún queda trabajo por hacer, te habras percatado que lo que esta antes del "\_" es el nombre del indicador y en el lado derecho se encuentran los años, así que es preferible trabajar con esta información en columnas separadas.

```{r}
datos_pivot <- datos_pivot %>% 
  separate(indicador,c("indicador","Año"),
                         sep="_")
```

-   El primer argumento es la columna que va a separar, en este caso es la variable "indicador".

-   `c("indicador", "Año"):` Este es un vector de caracteres que define los nombres de las nuevas columnas que se crearán como resultado de la separación.

-   `sep = "_":` Este argumento especifica el carácter o cadena de caracteres que se utilizará como separador para dividir la columna original.

```{r include=FALSE}
print(datos_pivot)
```


Probemos con otra forma: Este enfoque es más directo y eficiente que el método anterior que utilizaba primero `pivot_longer()` y luego `separate()`

```{r}
datos %>% pivot_longer(
  cols= -c(continent, country),
  names_to = c("indicador","Año"),
  names_sep = "_",
  values_to = "Valor"
)

```

-   `names_to = c("indicador", "Año")`: Aquí se especifica que los nombres de las columnas que se están pivotando se dividirán en dos nuevas columnas: indicador y Año.

-   `names_sep = "_"`: Este argumento indica que el separador entre los elementos que se moverán a las columnas indicador y Año es un guion bajo (\_).

Ahora, necesitamos que cada una de las categorias de la variable indicador sean variables independientes. La función pivot_wider() es el opuesto de pivot_longer(), y se utiliza para convertir datos de un formato largo a un formato ancho.

```{r}
datos_pivot <-  datos_pivot %>% pivot_wider(names_from=c(indicador),values_from = Valor)
```

-   `names_from = c(indicador, Año)`: Este argumento especifica las columnas del tibble largo cuyos valores se utilizarán para crear los nombres de las nuevas columnas en el tibble ancho.

-   `values_from = Valor`: Indica que los valores que se colocarán en las nuevas columnas provendrán de la columna Valor del tibble largo.

```{r include=FALSE}
print(datos_pivot)
```


Para evitar primero aplicar un `pivot_longer()` y posterior un `pivot_wider()` se pudo haber realizado en un solo paso y obtener el ismo resultado deseado:

```{r}
datos_pivot <- datos %>%
  pivot_longer(
    cols = -c(continent, country), 
    names_to = c(".value", "year"), 
    names_pattern = "(.+)_(\\d{4})"
  )
```

-   `cols = -c(continent, country)` indica que todas las columnas excepto continent y country deben pivotarse.

-   `names_to` Este argumento especifica cómo queremos nombrar las nuevas columnas en el conjunto de datos resultante.

-   `".value"`: Es una palabra clave especial en pivot_longer(). Le dice a la función que parte del nombre original de la columna (en este caso, gdpPercap, lifeExp, pop) debe usarse como nombre de la columna en el nuevo conjunto de datos. No es un nombre literal de columna; es una instrucción para la función sobre cómo manejar parte del nombre de la columna existente.

-   `"year"`: Esto indica que una parte del nombre de la columna original debe ir a una nueva columna llamada year.

-   `names_pattern` Este argumento es una expresión regular que indica cómo dividir los nombres de las columnas existentes.

-   `(.+)`: Esta es la expresión regular. (.+): El . significa "cualquier carácter", y + significa "una o más veces". Por lo tanto, (.+) captura cualquier secuencia de caracteres (en este caso, gdpPercap, lifeExp, pop). Estos caracteres son los que irán a las columnas indicadas por .value en names_to.

-   El guion bajo "\_" en la expresión regular actúa como un delimitador que separa claramente el identificador de la parte del año.

-   `(\\d{4})`: es un guion bajo literal. "\\d" significa "un dígito", y "{4}" significa "repetido cuatro veces". Así, "(\\d{4})"captura una secuencia de cuatro dígitos (en este caso, el año, como 1952, 1957, etc.). Estos dígitos son los que irán a la columna year.

```{r include=FALSE}
print(datos_pivot)
```

Ahora que ya contamos con los datos en una estructura rectangular, podemos continuar con nuestra manipulación de datos.

### Transformar y crear nuevas variables

`mutate()` no solo facilita la transformación de variables existentes, sino que también es clave en la creación de nuevas variables. Estas nuevas variables pueden ser derivadas de las ya existentes o pueden ser completamente nuevas, basadas en cálculos o reglas específicas definidas por ti.

Hechemos de vista la estructura actual de nuestros datos:

```{r}
glimpse(datos_pivot)
```

Las variables continent y country, son variables categoricas debido a que poseen un conjunto fijo y conocido de los valores posibles, es por eso que de preferencia se necesita definir a estas variables como factor, del mismo puedes especificar que una columna es de tipo "fecha".

Vamos a modificar estas variables sin crear unas nuvevas:

```{r}
datos_pivot <- datos_pivot %>% mutate(continent=as.factor(continent),
       country=as.factor(country),
       year=as.Date(
                paste(year,"01-01",sep="-")))

```

```{r include=FALSE}
print(datos_pivot)
```

Ahora, probemos creando nuevas variables a partir de las que ya se encuentran creadas.

```{r}
datos_pivot <- datos_pivot %>%
  mutate(log_gdpPercap=log(gdpPercap),
         log_lifeExp=log(lifeExp),
         log_pop=log(pop),
         var_gdpPercap=gdpPercap-lag(gdpPercap),
         varre_gdpPercap=gdpPercap/lag(gdpPercap)-1)

```

```{r include=FALSE}
print(datos_pivot)
```

Creemos ahora una nueva variable, tomando como base la clasificación de los países elaborada por el Grupo Banco Mundial (2023):

```{r}
datos_pivot <- datos_pivot %>%
  mutate(
    clasificacion=
      case_when(
  gdpPercap <= 1136 ~ "Ingreso bajo",
  gdpPercap > 1136 & gdpPercap <= 4466 ~ "Ingreso medio bajo",
  gdpPercap > 4466 & gdpPercap <= 13865 ~ "Ingreso medio alto",
  gdpPercap > 13865 ~ "Ingreso alto"
),
clasificacion=factor(clasificacion, levels =c("Ingreso bajo","Ingreso medio bajo", "Ingreso medio alto", "Ingreso alto"), ordered = TRUE))

```

```{r include=FALSE}
print(datos_pivot)
```

Otra función útil que puede combinarse con `mutate()`es `ifelse()`

```{r}
datos_pivot <- datos_pivot %>% mutate(variacion=ifelse(var_gdpPercap>0,"positiva","negativa"))

```

```{r include=FALSE}
print(datos_pivot)
```

`transmute()` El uso de esta función es similar a `mutate()`, la diferencia radica en que muta y selecciona a la vez, probemos:

```{r}
datos_pivot %>%
  transmute(country,
    clasificacion=
      case_when(
  gdpPercap <= 1136 ~ "Ingreso bajo",
  gdpPercap > 1136 & gdpPercap <= 4466 ~ "Ingreso medio bajo",
  gdpPercap > 4466 & gdpPercap <= 13865 ~ "Ingreso medio alto",
  gdpPercap > 13865 ~ "Ingreso alto"
),
clasificacion=factor(clasificacion, levels =c("Ingreso bajo","Ingreso medio bajo", "Ingreso medio alto", "Ingreso alto"), ordered = TRUE))
```

### Resúmenes 

`summarise` Nos permite crear resúmenes estadísticos.

```{r}
datos_pivot %>% summarise(
  promedio_lifeExp=mean(lifeExp, na.rm=TRUE),      valor_max_gdp=max(gdpPercap),
  valor_min_gdp=min(gdpPercap),
  mediana=median(gdpPercap)
)
```

En este caso se utilizó `summarise()`para casos didacticos, sin embargo, para obtener resumenes estadísticos se utiliza `summary()`

```{r}
summary(datos_pivot)
```

Eso no quiere decir que `summarise()` no sea útil, de hecho combinandola con `group_by()` tiene una gran funcionalidad. Para ejemplificar esto, supongamos que queremos obtener el promedio de lifeExp no de forma general sino por cada continente.

```{r}
datos_pivot %>% 
  group_by(continent) %>% 
  summarise(promedio=mean(lifeExp))
```


Otro ejemplo:
```{r}
datos_pivot %>% 
  group_by(continent,year) %>% 
  summarise(promedio=mean(lifeExp))
```

### Resúmenes agrupados

`group_by()`se puede adaptar para las otras funciones que hemos visto y para muchas más, probemos con `count()`, que tal si contamos cuantas países por continente constan en nuestros datos:

```{r}
datos_pivot %>% 
  group_by(continent) %>% 
  distinct(country) %>% 
  count()
```


### Unión de datos

En el análisis de datos, a menudo nos encontramos con la necesidad de integrar información de distintos marcos de datos. Afortunadamente, R ofrece varias herramientas para esto, entre ellas los `joins`, que son parte integral del paquete `dplyr`.

Al realizar uniones entre diferentes conjuntos de datos, es crucial tener una "clave" o "llave", es decir, una columna en cada marco de datos que sirva como identificador único para cada observación. Un buen ejemplo de esto son los nombres de los países. 

En esta sección vamos a ver el uso de:
  `inner_join()`,
  `left_join()`,
  `rigth_join()`y
  `full_join()`
 
Se puede hacer uso de los `joins`para filtras nuestras observaciones, con 
`semi_join` y `anti_join`.

Para mostrar el uso de estas funciones, utilizaremos el conjunto de datos denominado `desempleo` y nuestros datos manipulados `datos_pivot`.

```{r}
print(desempleo)
```

```{r}
#Seleccionemos la variables de interes y cambiemos uno de los nombres de las variables
desempleo <- desempleo %>%     
  select(country,date,SL.UEM.TOTL.ZS) %>%  
  rename(tasa_desem=SL.UEM.TOTL.ZS) %>% 
  mutate(date=as.Date(paste(date,"01-01",sep="-")))

#Nota: rename() es otra de las funciones de dplyr, se utiliza para renombrar variables, la sintexis es rename(nombre_nuevo=nombre_viejo).

#El siguiente código ayuda a quitar el comentario de la columna
attributes(desempleo$tasa_desem) <- NULL

```

```{r include=FALSE}
print(desempleo)
```

### Intersección de observaciones

`inner_join()`Esta función se utiliza para traer observaciones que coinciden en los dos marcos de datos.

Es crucial recordar que, para realizar uniones efectivas, las claves utilizadas deben ser del mismo tipo de datos. Por ejemplo, si una clave en un conjunto de datos es una fecha y en otro es un texto, no se podrán unir correctamente.

```{r}
datos_pivot %>% inner_join(desempleo,        by=c("country","year"="date"))%>%
relocate(tasa_desem, .after= year)
```

- La unión de nuestros datos resulta en una relación "many-to-many", ya que la clave (el nombre del país) se repite debido a registros anuales por país. Esto conlleva una combinación de múltiples filas para cada país de ambos conjuntos de datos.

- En este caso, para evitar la combinación de "many-to-many" y asegurar que la unión refleje con precisión las relaciones entre los datos vamos a utilizar claves más específicas.

```{r}
datos_pivot %>% inner_join(desempleo,        by=c("country","year"="date"))%>%
relocate(tasa_desem, .after= year) 
```

**NOTA** Para unir nuestros datos, usamos "country" como clave común en ambos tibbles. Sin embargo, hay una diferencia en cómo se registran los años: en datos_pivot es year, mientras que en desempleo es date. Por ello, es crucial especificar estas columnas correspondientes en la función de unión para asegurar una combinación correcta.


### Combinaciones de izquierda

`left_join()` Mantiene todas las filas del primer conjunto de datos (izquierdo) y añadiendo las columnas del segundo conjunto de datos (derecho) cuando las claves coinciden. Las filas del conjunto de datos izquierdo que no tienen coincidencia en el derecho se mantienen, con los valores del derecho puestos como `NA` en las columnas añadidas.

```{r}
datos_pivot %>% left_join(desempleo,         by=c("country","year"="date"))%>%
relocate(tasa_desem, .after= year)
```

### Combinaciones de derecha
`right_join()` Conserva todas las filas del conjunto de datos derecho y añadiendo columnas del izquierdo donde coincidan las claves. Las filas del conjunto derecho sin correspondencia en el izquierdo se mantienen, con valores NA en las nuevas columnas.

```{r}
datos_pivot %>% right_join(desempleo,        by=c("country","year"="date"))%>%
relocate(tasa_desem, .after= year)
```

### Combinación completa

`full_join()` Mantiene todas las filas de ambos, y llenando con NA las no coincidencias.

```{r}
datos_pivot %>% full_join(desempleo,         by=c("country","year"="date"))%>%
relocate(tasa_desem, .after= year) 
```

Ya para finalizar, recuerdas que en secciones anteriores vimos como filtrar datos según tus condiciones, esto tambien se puede realizar con los `joins`.

### Filtrar observaciones con joins

`semi_join()` Selecciona todas las filas del primer conjunto de datos (izquierdo) que tienen una coincidencia en el segundo conjunto (derecho), basándose en una clave común. No añade nuevas columnas, solo filtra filas.

```{r}
datos_pivot %>% semi_join(desempleo,        by=c("country","year"="date"))
```
Como podrás observar, obtenemos sola las observaciones de los países latinos, debido a que solo esos constan en el tibble desempleo.

`anti_join()` Devuelve todas las filas del primer conjunto de datos (izquierdo) que no tienen una coincidencia en el segundo conjunto (derecho), basándose en una clave común. 
```{r}
datos_pivot %>% anti_join(desempleo,        by=c("country","year"="date"))
```

Se obtiene las observaciones de los países que no son latinos, debido a que estos no contan en el tibble desempleo.

