---
title: "Curso de Importación y Manipulación de datos con R"
author: "Jhanelly Chalá"
output: 
   rmdformats::readthedown:
    self_contained: false
---

```{=html}
<style>

h1.title {
  text-align: center;
}

body {
  text-align: justify;
  text-justify: inter-word;
}

</style>
```

------------------------------------------------------------------------

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=FALSE)
```

# Importar datos con R

![](https://d33wubrfki0l68.cloudfront.net/571b056757d68e6df81a3e3853f54d3c76ad6efc/32d37/diagrams/data-science.png){alt="Flujo de Trabajo para Analítica de Datos en R: Inspirado por las Técnicas de Wickham y Grolemund" style="display: block; margin-left: auto; margin-right: auto;" width="60%"}

::: {style="text-align: center;"}
Flujo de Trabajo para Analítica de Datos en R: Inspirado por las Técnicas de Wickham y Grolemund
:::

La imagen presentada ilustra un modelo de herramientas necesarias para trabajar con datos, propuesto por Hadley Wickham & Garret Grolemund.

En esta primera sección del curso cubriremos la importación de datos, una acción fundamental para poder hacer análisis de datos.

En R se pueden cargar datos de diferentes tipos de archivos como por ejemplo:

|       |                            |
|-------|----------------------------|
| .csv  | Datos separados por comas  |
| .dta  | Datos de Stata             |
| .sav  | Datos provenientes de SPSS |
| .xlsx | Datos excel                |

¡Y muchos más, continua leyendo!

**¿Por qué en importante conocer la ruta de trabajo?**

Trabajar en un espacio de trabajo predefinido facilita la importación de datos, dado que no es necesario especificar la ruta completa del archivo en cada importación. Por tal motivo, se recomienda almacenar toda la información en una misma ruta.\
\
Otra recomendación útil es organizar tus tareas, trabajos e investigaciones en proyectos separados. De esta manera, cada vez que abras una sesión en un proyecto específico, la ruta de trabajo ya estará predefinida según la ubicación donde se almacene dicho proyecto. Esto facilita el manejo de archivos y mejora la eficiencia en el acceso a los recursos necesarios.

**Conoce tu diractorio de trabajo**:

```{r echo=TRUE}
getwd() #Obtendras una salida parecida a esta:

```

**¿Puedo cambiar mi directorio de trabajo?**

Si deseas usar otra ruta distinta para importar tus archivos lo puedes hacer con el siguiente comando:

```{r}
setwd("C:/Users/USUARIO/Documents/Publicaciones/CURSO_R")
```

**NOTAS:**

1.  Recuerda que tienes que usar **\\\\** o **/**, además toda la ruta debe estar dentro de las comillas.

2.  Al iniciar una nueva sesión, la ruta de trabajo se restablecerá\

Si deseas prácticar con los datos usados aquí, puedes descargarlos [aquí](https://github.com/Jhanelly/CURSO_R.git)

### **Importación de datos tabulares .csv**

No es necesario instalar paquetes adicionales para importar datos de extensión .csv Se puede hacer desde el paquete base que contiene R.

Prueba lo siguiente:

```{r eval=FALSE, eval=FALSE}
read.csv("Nombre_del_archivo.csv", col_names = FALSE, 
         skip = n)
```

`col_names=TRUE:` Indica que la primera fila corresponde a los nombres de las columnas, `skip=n`Omite las primeras 'n' filas del archivo antes de comenzar a leer los datos.

Recuerda que al estar el archivo dentro de tu ruta de trabajo no necesitas usar toda la ruta del archivo. En caso de que desees importar el archivo desde otra carpeta sin necesidad de cambiar la ruta de trabajo, podrías probar con algo como esto:

**NOTA:**

Puedes utiliza la función `choose.files()` para encontrar la ruta de tu archivo con mayor facilidad.

Si estas trabajando con grandes conjuntos de datos, puedes optar por utilizar el paquete `data.table`, el cual permite optimizar el tiempo y memoria al leer los datos.

```{r}
#install.packages("data.table")
library(data.table)
dt <- fread("Nombre_del_archivo.csv")
```

### **Importar datos .dta**

Para importar datos de extensión .dta o .sav se necesita el siguiente paquete:

```{r}
#install.packages("haven")
library(haven)

read_dta("Nombre_del_archivo.dta")
```

### **Importar datos .sav**

```{r, eval =FALSE}
library(haven)
read_spss("Nombre_del_archivo.sav") 
```

### **Importar datos de excel**

Para importar datos de excel puedes usar los paquetes `readxl` o `openxlsx`

```{r}
#install.packages("readxl") #Permite importar archivos
#install.packages("openxlsx") #Permite importar y exportar
library(readxl)
library(openxlsx) 

```

Probemos con el paquete readxl:

```{r}
read_excel("Nombre_del_archivo.xlsx", sheet = 1)
```

Con el argumento `sheet` puedes especificar el número de hoja a importar o bien el nombre de la misma, ejm: "Precios"

**¿Se puede importar más de un archivo a la vez?**

En nuestros proyectos nos podemos encontrar que deseamos importar más de un archivo, sería engorroso importar uno por uno, sin embargo, no te debes preocupar, las funciones de R se crearon para ayudar!!

**CONSEJO:** Puedes optar por crear en tu ruta una carpeta que contenga especificamente los archivos con la misma extensión que deseas de importar:

Para el ejemplo la nueva carpeta se denomina "bases".

```{r}
files<-list.files(path = "bases",full.names = TRUE)
```

`list.files():` Esta es una función en R que se utiliza para listar los nombres de los archivos en un directorio especificado.

`path = "bases":` Este argumento indica el directorio del cual se quieren listar los archivos. En este caso, está buscando en el directorio llamado "bases". Si este directorio está dentro del directorio de trabajo actual, buscará allí; de lo contrario, necesitarás proporcionar una ruta completa o relativa.

`full.names = TRUE:` Este argumento especifica que los nombres de los archivos devueltos deben incluir sus rutas completas. Si estuviera en FALSE (que es el valor predeterminado), list.files() devolvería solo los nombres de los archivos sin la ruta.

Hasta ahora solo hemos guardado los nombres de los archivos, para importarlos puedes hacerlo con el siguiente comando:

```{r}
bases<-lapply(files,read_xls, sheet=1) 
```

El código está aplicando la función read_xls a cada uno de los archivos especificados en files, leyendo la primera hoja de cada archivo Excel y almacenando los resultados en la variable bases.

Extraiga los archivos almacenados en la lista:

```{r eval=FALSE}
electricidad <- bases[[1]]
pib <- bases[[2]] 
```

Estas líneas de código están separando los DataFrames individuales almacenados en la lista bases en variables separadas para su uso y análisis más fácil.

### **Datos provenientes de Internet**

R brinda la facilidad de poder descargar archivos de internet con comandos, ¡Que locura!

Imagina que los datos que necesitas se encuentran en el siguiente url:

```{r}
url <- "https://raw.githubusercontent.com/zkamvar/r-novice-gapminder/main/episodes/data/gapminder_wide.csv"

#Cargar los datos
dato <- read_csv(url)
```

### **Web Scraping**

El web scraping se utiliza cuando los datos no están disponibles en un formato fácilmente descargable, como un archivo CSV, sino que están incrustados en el HTML de una página web.

Las APIs (Interfaces de Programación de Aplicaciones) son conjuntos de reglas que permiten a las aplicaciones interactuar entre sí. Actúan como intermediarios, facilitando el acceso a funciones o datos de otros servicios de forma estandarizada. Su uso es fundamental para integrar y ampliar las capacidades de las aplicaciones de software.

**API Banco Mundial**

Cargar e instalar el paquete necesario:

```{r}
#install.packages("wbstats")
library(wbstats)
```

Puedes utrilizar el paquete de la siguiente manera:

```{r}
#Indicadores disponibles
wbindicators() 
#Para obtener los indicadores en español:
wbindicators(lang = "es") 
#Datos relacionados con turismo
wbsearch(pattern = "turismo")
#Descarga los datos que necesites
turismo <- wb_data(indicator = "ST.INT.ARVL", country = "EC",
                   start_date = 1995, end_date = 2020)

#Si deseas de todos los países y todos los años disponibles, no es necesario que se especifiquen los argumentos country, start_date y end_date.
```

# Manipulación de datos con R

Habiendo importado nuestros datos en R, estamos listos para el siguiente paso en nuestro flujo: la transformación de datos. Aunque el ordenamiento y limpieza ('tidy') son cruciales, nos centraremos primero en transformar los datos, integrando gradualmente el proceso 'tidy' para demostrar su importancia en el análisis de datos.

Empecemos por conocer otro tipo de marco de datos denominado **tibble**. Los tibbles son una versión moderna y mejorada de los data frames en R, diseñados específicamente para el ecosistema Tidyverse. Aunque similares en estructura, los tibbles mejoran la experiencia del usuario con una impresión más amigable en la consola, manejo más intuitivo de las variables no estándar y una mayor compatibilidad con los datos almacenados en formatos diversos. Estas características hacen de los tibbles una opción preferida para el análisis de datos en R.

Almacenemos nuestro datos en un objeto tibble:

```{r}
library(tibble)
datos <- as_tibble(data1) #convertir a un tibble
glimpse(datos) #similar a str() pero es útil con los tibble
```

Una vez obtenido los datos en el formato que necesitamos, podemos empezar.

Dentro de R, dplyr es un paquete esencial para la manipulación de datos, este además de tibble forma parte del mundo tidyverse. 
```{r}
#install.packages("dplyr")
library(dplyr)
```

Los verbos principales que integran sus funciones son:

1.  `filter()`,

2.  `select()`,

3.  `arrange()`,

4.  `mutate()`,

5.  `summarise()` y

6.  `group_by()`.

Cada una de estas funciones juega un papel esencial en la transformación y análisis de datos. Además de estas herramientas fundamentales, también exploraremos funciones adicionales dentro de dplyr para enriquecer tu comprensión y habilidades en el manejo de este paquete.


`filter()`permite crear un sub-conjunto de las observaciones de nuestro datos.

-   Comparaciones

Counto estándar: \>, \>=, \<, \<=, !=(no igual) y ==(igual)

```{r}
#Filtra por el continente que sea Africa
datos %>% filter(continent=="Africa")
#Filtra las observaciones de gdpPercap_1952 que sean mayores o iguales a 5000
datos %>% filter(gdpPercap_1952>=5000)
#Filtra las observaciones de gdpPercap_1952 que tengan valores NA
datos %>% filter(is.na(gdpPercap_1952))

#Filtrar por exepción
#Filtra observaciones en las que el país NO sea Algeria.
datos %>% filter(!country=="Algeria")
```

El operador %>%, conocido como el operador de tubería (pipe operator), Permite encadenar múltiples funciones de manera clara y legible, pasando el resultado de una función como primer argumento a la siguiente. Forma parte del paquete `magrittr` pero si ya has cargado `dplyr` previamente, tendrás el operador `%>%`  disponible automáticamente.

-   Operadores lógicos

El operador | es un operador lógico "OR" que permite incluir filas que cumplan cualquiera de las dos condiciones.

```{r}
datos %>% filter(country=="Ecuador" | Provincia=="Chile")

#Otra opción es:
#Operador %in%
datos %>% filter(country %in% c("Ecuador", "Chile", "Mexico"))

```

El operador &, que es un operador lógico "AND", lo que significa que ambas condiciones deben ser verdaderas para que una fila sea incluida en el resultado.
```{r}
datos %>% filter(continent=="Europe"& gdpPercap_1952<5000)

#Puedes utilizar:
datos %>% filter(continent=="Europe", gdpPercap_1952<5000)
```

Dentro de la manipulación de casos tambien es útil `distinct()` para obtener solo los registros únicos de la columna

```{r}
datos %>% distinct(continent) 
```

Cuando se trabaja con datos que poseen cadenas de texto, se puede combinar filter con otras funciones de otros paquetes, como por ejemplo: `stringer` uno más del ecosistema tidyverse.

La función `str_detect` se utiliza para identificar si un patrón específico de texto está presente en una cadena de caracteres.

```{r}
library(stringr)
# Filas donde la columna Provincia contiene la letra "a" en cualquier parte de su texto
datos %>% filter(str_detect(country,"o"))
# Filas donde Provincia comienza con la letra "C"
datos %>% filter(str_detect(country,"^A"))
# Filas en donde las cadenas terminen con la letra "a"
datos %>% filter(str_detect(country,"s$"))
```

`select()` Permite obtener un subconjunto de datos solo con las variables (columnas) de interés.

Seleccionar Columnas Específicas:
```{r}
datos %>% select(country, gdpPercap_1952, lifeExp_1952, pop_1952)
```
Excluir columnas:
```{r}
#Una
datos %>% select(-continent)
#Múltiples
datos %>% select(-continent, -gdpPercap_1957)
#Forma adicional
datos %>% select(-c(continent, gdpPercap_1957))
#Rango de columnas
datos %>% select(country,gdpPercap_1957:gdpPercap_2007) 
```

Dentro de `select()` puedes utilizar otras funciones de ayuda

```{r}
#Columnas que inicien con "lifeExp"
datos %>% select(country,starts_with("lifeExp"))

#Seleccionar columnas que contengan "Gdp":
datos %>% select(country, contains("Gdp"))

#Seleccionar columnas que finalicen con "1997":
datos %>% select(country, ends_with("1997"))
```

El orden de las variables tambien se establece con select(), así que si deseas colocar una columna al inicio de todas las demás, se puede usar:
```{r}
#Mueve la columna Provincia al principio del conjunto de datos, manteniendo todas las demás columnas en su orden original.
datos %>% select(country,everything())
```

Para cambiar la posición de las columnas tambien se utiliza `relocate()`
```{r}
#La función relocate() por defecto coloca la columna especificada al inicio del conjunto de datos:
datos %>% relocate(country)
#Mover una Columna a una Posición Específica
datos %>% relocate(c(lifeExp_1997, pop_1997),.before=gdpPercap_1952)
#Caso 1
#El argumento .before=gdpPercap_1952 indica que lifeExp_1997 debe ser colocada antes de gdpPercap_1952
#Caso 2
datos %>% relocate(c(lifeExp_1997, pop_1997),.after=gdpPercap_1952)
#El argumento .after=gdpPercap_1952 indica que lifeExp_1997 debe ser colocada antes de gdpPercap_1952
```

`arrange()` se utiliza para ordenar las filas de un conjunto de datos

```{r}
#Orden ascendente
datos %>% arrange(country)
#Orden descendente
datos %>% arrange(desc(gdpPercap_1952))
#Ordenar por varias columnas
datos %>% arrange(continent,desc(country))
#Esta última linea indica que se ordenará de forma ascendente por la variable continent y luego ordenara de forma descendente por la variable country.

#Nota: Al ser caracteres el orden es alfabetico
```

Aun tenemos unos verbos más que aprender, sin embargo, antes de ver los demás, me parece un buen momento para retomar un paso importante nombrano en los parrafos anteriores: tidy.

En nuestro conjunto de datos, que actualmente presenta una estructura "ancha" con columnas separadas para cada año y cada indicador (como gdpPercap_1952, lifeExp_1952, etc.), vamos a realizar una transformación para adoptar un formato "largo" o "rectangular".  

En el formato rectangular, cada fila representará una observación única para un país en un año específico, con columnas dedicadas para year, gdpPercap, lifeExp, y pop. 


```{r}
#install.packages("tidyr")
library(tidyr)

datos_pivot <- datos %>% 
  pivot_longer(cols = -c(continent, country),
                names_to="Indicador",
                values_to = "Valor")  

datos_pivot <- datos_pivot %>% separate(Indicador,c("Indicador","Año"),
                         sep="_")
```

Probemos con otra forma:
```{r}
datos %>% pivot_longer(
  cols= -c(continent, country),
  names_to = c("Indicador","Año"),
  names_sep = "_",
  values_to = "Valor"
) %>% view("pivot_pw")

```

Si quisiera revertir?
```{r}
datos_pivot %>% pivot_wider(names_from=c(Indicador,Año),values_from = Valor,names_sep=".")
```


Ahora que ya contamos con los datos en una estructura rectangular, podemos continuar con nuestra manipulación de datos.



